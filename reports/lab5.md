# 实现的功能
1. Mutex测试例中好像并不会发生死锁，因此只实现了一个简单的功能，检查该资源是否被锁。
2. 信号量机制中，我设置了我在整个内核中设置了work数组，代表每个资源还有的数目。在每个线程的控制块添加need数组，代表这个线程需要的各种资源的数目。
3. 最终我的代码还是有些问题，线程可能因为时间片切换或者自己需要/得到资源阻塞或者被唤醒，work和need数组有时可能不能及时更新。

# 问答题
1. 需要回收的资源包括：线程栈空间、堆空间、文件描述符等资源。 其他线程的TCB可能在进程的线程调度队列中，需要被回收，因为整个进程都被回收了。
2. 二者对于locked设置的时机不同。在 Mutex1 的实现中，先将 locked 标志位设置为 false，然后再检查等待队列并取出任务添加到可执行任务队列中。
   在Mutex2 的实现中，先检查等待队列，如果等待队列为空，再将 locked 标志位设置为 false；如果等待队列不为空，则取出任务添加到可执行任务队列后不设置 locked 标志位。
   如果在将 locked 标志位设置为 false 后，但是在从等待队列中取出任务并添加到可执行任务队列之前发生了上下文切换，那么另一个线程可能会在这个间隙中获取到这个 Mutex， 
而此时等待队列中的任务还未被唤醒，可能导致等待队列中的任务永远无法被唤醒，从而造成死锁或者任务饥饿的问题。如果在检查等待队列后，准备设置 locked 标志位为 false 之前发生了上下文切换，并且另一个线程尝试获取这个 Mutex，那么这个新的线程可能会被错误地阻塞，因为 locked 标志位仍然为 true。而实际上，等待队列已经为空，这个 Mutex 应该是可用的。这也可能导致死锁或者任务饥饿的问题。
# 荣誉准则
在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：春季训练营的课件和讲义。

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
# 本次实验的收获
   1. 了解了互斥锁、信号量等线程同步机制的实现原理。和死锁的产生原因。知道怎么避免死锁。在内核中实现这些机制。