# 实现的功能
1. 重写 sys_get_time 和 sys_task_info:这两个系统调用需要重写的原因是因为传入的指针是虚存地址，而不是物理地址，所以需要通过translated_byte_buffer函数来获取访存接口，然后把对应的数据复制进来，再进行读取和修改。
2. mmap 和 munmap 匿名映射：
   1. mmap主要功能是映射文件到物理内存中，需要先检查参数合法性，再调用task-memoryset的insert_framed_area方法来实现主要功能。
   2. munmap则需要查看对应的虚存区间是否在task-memoryset的areas里面。如果存在对应区间就取消映射，否则返回-1。
   3. 需要注意权限位的转换和区间端点的处理。
# 问答题
1. SV39的页表项一共有64位。[63:54]10位是保留位。[53:10]44位是物理页号。[9:8]2位是权限位。[7:0]8位是标志位。其中标志位的定义如下：
   1. [0]位是有效位，表示该页表项是否有效。
   2. [1]位是读位，表示是否可读。
   3. [2]位是写位，表示是否可写。
   4. [3]位是执行位，表示是否可执行。
   5. [4]位是用户位，表示是否是用户态可访问。
   6. [5]位是全局位，表示是否是全局页。这个位可以用于共享一些全局的页面，比如内核代码。除了这个位，其他位都可以被操作系统修改。
   7. [6]位是已使用位，表示是否被访问过。
   8. [7]位是脏位，表示是否被修改过。
2. 缺页
   1. 缺页通常会导致页故障异常。
   2. sepc：会保存发生缺页异常时正在执行的指令的地址。在异常处理完成后，可以根据sepc的值恢复程序的执行，使程序能够从异常发生的位置继续执行。
      sstatus：包含了处理器的状态信息。在缺页异常发生时，其状态信息（如中断使能位等）对于异常处理的流程和后续恢复操作有重要作用。
   3. Lazy策略可以节省内存资源，加快程序启动速度。
   4. 在 SV39 模式下，虚拟地址空间为 39 位，页面大小通常为 4KB（字节）。所以虚拟地址空间中的页面数为2^27个。
      页表项大小为 8 字节，若全部页面都有对应的页表项，页表大小约为字节。
      对于 10G（字节）内存，页面数约为10x2^18个。
      相应的页表大小估算约为8x10x2^18字节，数量级约为10x2^21字节，即约为20MB。
   5. Lazy 策略实现：可以在页表项中添加一个额外的标志位来表示页面是否已经被实际加载。当程序访问一个尚未加载的页面时，先检查这个标志位。如果标志位表示未加载，就触发加载系统调用/缺页异常处理。
   6. 当内存页面被交换到磁盘上时，页表项中的有效位（V 位）会被设置为 0，表示该页面目前在页表中是无效的。
3. 单页表：
   1. 用户线程和内核线程共享同一个页表，在切换线程时需要切换页表。
   2. 在页表项中，应该有一个U位，表示是否是用户态可访问。
   3. 单页表比较简单，而且内存占用较少。在频繁切换内核态和用户态时，单页表的切换效率较高。
   4. 双页表时，在进程切换或者内核态和用户态切换时，可能需要切换页表。单页表操作系统更换页表可以选择在进程或者线程调度时进行。
# 荣誉准则
在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：春季训练营的课件和讲义。

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
# 本次实验的收获
1. 了解了mmap和munmap的实现原理。
2. 了解了页表项的结构和作用。和SV39虚拟内存的实现。