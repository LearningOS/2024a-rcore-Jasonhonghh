# 实现的功能
编程作业中要求实现新的系统调用`sys_task_info`,用于获取当前任务的信息。我主要实现了：
1. 修改了TCB结构体，增加了一些字段用于保存任务的信息。
2. 给TaskManager增加了一个新的方法get_current_task_info()，用于获取当前任务的信息。
3. 在task crate中暴露get_current_task_info()方法，供系统调用使用。

# 问答题
1. 我使用的是qemu 7.0.0版本。执行这些程序时处于用户态，三个测例出错行为如下 
   1. ch2b_bad_addresss：这个测例会访问一个非法地址0x00。在qemu模拟的virt硬件平台上，物理内存的起始物理地址为 0x80000000。这个0x00地址是用户态不可访问的。
   2. ch2b_bad_instructions：这个测例会执行一个非法指令sret。尝试从S态返回U态。这个指令是用户态不可执行的。
   3. ch2b_bad_registers：这个测例会访问一个非法寄存器sstatus寄存器。即监督者状态寄存器。这个寄存器是用户态不可访问的。
2. __alltraps 和 __restore相关问题的答案
   1. 刚进入 __restore 时，a0中保存的是内核栈的栈指针，也就是Trap 上下文的地址，trap_handler的第一个参数cx需要从a0寄存器获取，需要知道应用程序的syscall ID和对应的参数，此时需要根据a0来找到内核栈中我们保存的trap上下文，在__restore之前不会修改它。__restore的主要作用是恢复上下文，在risc-v中，在发生中断和异常时，需要使用它。
   2. 特殊处理了sstatus、spec、sscratch寄存器。sstatus的SPP等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息。而spec寄存器记录了异常引起的 Trap 发生之前执行的最后一条指令的地址。sscratch保存了trap之前用户程序用户栈的栈顶指针，恢复sscratch的值可以确保正确地切换回用户栈。
   3. x2寄存器用作栈指针，即sp寄存器，x4用作线程指针。用户栈指针被恢复了。线程指针没用到，不用恢复。
   4. `csrrw sp, sscratch, sp`指令交换了sscratch和sp的值。sp指向了用户栈的栈顶，sscratch指向了内核栈的栈顶。
   5. __restore中状态切换发生在，l46，`csrw sstatus, t0`，这里将t0的值写入sstatus寄存器，切换了特权级。
   6. `csrrw sp, sscratch, sp`指令交换了sscratch和sp的值。sp指向了内核栈的栈顶，sscratch指向了用户栈的栈顶。
   7. 当 CPU 执行完指令ecall准备从用户特权级 陷入（ Trap ）到 S 特权级的时候，硬件会自动完成对当前特权级的保存和切换。执行__alltraps时，CPU 已经切换到了 S 特权级。
# 荣誉准则
在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：春季训练营的课件和讲义。

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
# 本次实验的收获
了解了如何在rCore系统中实现新的系统调用，以及如何在用户态中调用系统调用。在实现过程中，我对rCore系统的结构有了更深入的了解。